<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: commands/google.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: commands/google.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// Imports
const discord = require('discord.js');
const fetch = require('node-fetch');
const errh = require('./helpers.js').err;
const { log, randomnoise, Perms } = require('./helpers.js')
const timer = 20000;        // Timer in ms
/**
 * Reaction emojis to add to a monkey result
 * @type {String[]}
 */
const reactions = ['🟧','🟥','🟪','🟦','⬜', '❌'];
/**
 * Reaction colors and description
 * @type {String[][]}
 */
const colors = {
    '🟧': ["#ff7b00", "★ Contraband"],
    '🟥': ["#f21331", "Covert "],
    '🟪': ["#ed1ad8", "Classified"],
    '🟦': ["#2ea2e6", "Uncommon"],
    '⬜': ["#fafafa", "Common"], 
    "❌": ["#474747", "Delete"]
};

// --------------------
// Modifiable globals

/**
 * @description When we get a result from the Google Custom Search Engine API
 * we want to hold onto all the results until we use them up. For the time been
 * we're going to store them into this variable in memory since our usage is low.
 * Need to move this to a database in the future for scalablity reasons.
 * 
 * Reason for this is due to a 100 query limit when for searching. Hopefully querying
 * for 10 results should mean we have a limit of 1,000 images per API key
 */
let google_results = [];
/**
 * @description Incriment this variable when we reach the quota of an 
 * API key to move to another one
 * @type number
 */
let quote_reached = 0;
/**
 * @type boolean[]
 * @example vote[server.id] = True|False
 */
let vote = [];

/**
 * @description 'Endpoint' for our monkey image searcher sends a message for voting
 * and then sends a final message.
 * @async
 * @param {Object} msg 
 * @param {Promise&lt;Object>} res
 * @fires Reaction_Result
 */
async function sendMessage(msg, res)
{
    const perms = new Perms(msg);
    if(perms.del() &amp;&amp; perms.react()) // Check to see if we have permissions to modify chat and add reactions
    {
        const expirey = timer/1000; // Timer in seconds
        google_results.shift();     // Delete an instance of google images in storage (dumb and stupid, is called when do reddit as well) 
        vote[msg.guild.id] = true;  // Voting is in progress

        // Embed messiness
        const embed = new discord.MessageEmbed()
        .setColor(process.env.BOT_COLOR)
        .setAuthor(randomnoise(), msg.client.user.displayAvatarURL())
        .setTitle(res['title'])
        .addField("Rankings",`${reactions[0]} ★ Contraband\n${reactions[1]} Covert\n${reactions[2]} Classified\n${reactions[3]} Uncommon\n${reactions[4]} Common\n${reactions[5]} Delete`)
        .setURL(res['link'])
        .setImage(res['link'])
        .setFooter(`This vote will expire in ${expirey} seconds`);
        // Send message and wait for reactions
        msg.channel.send(embed).then(async e=>Reaction_Result(msg, e, res))
    }
    else
    {
        const random = Math.floor(Math.random() * Object.keys(colors).length);
        const key = Object.keys(colors)[random];
        const ran_colour = colors[key][0]

        const embed = new discord.MessageEmbed()
        .setAuthor(randomnoise(), msg.client.user.displayAvatarURL())
        .setDescription('Missing permissions for voting. Selected random rating (Random ranking will be replaced with smart ranking... eventually)')
        .setColor(ran_colour)
        .setTitle(`${res['title']}`)
        .setURL(res['link'])
        .setImage(res['link'])
        .setFooter(`${msg.author.username}#${msg.author.discriminator}`, `${msg.author.avatarURL()}`)
        .setTimestamp();
        msg.channel.send(embed);
    }
}
/**
 * @description Add reactions ranking m
 * @async
 * @param {Object} msg 
 * @param {Promise&lt;Object>} e Message sent by the bot for voting
 * @param {Promise&lt;Array>} res List
 * @fires Reaction_Result
 */
async function Reaction_Result(msg, e, res)
{
    reactions.forEach(square=>{e.react(square)})                                                                    // Reacting with the voting squares 
    const filter = async (reaction, user) => reactions.includes(reaction.emoji.name) &amp;&amp; user.id === msg.author.id;  // Some filtering shit?
    const result = await e.awaitReactions(filter, {time: timer})                                                    // Reactions from users

    let output = [], i = 0, users = [];                                                                                 // Settings up objects for next 
    result.forEach(t=>{output.push([t._emoji['name'], t.count, t.users]);i++;});                                        // Looping trhough the reactions and pushing the results into an array

    vote[msg.guild.id] = false;
    output.sort((a,b)=>{return b[1] - a[1]})

    console.log(output[0][2]);
    output[0][2].cache.forEach(user=>{!user.bot ? users.push(`${user.username}`) : ''})
    users = users.join(", ");

    e.delete().catch();                      // Delete the message sent for voting
    if(output[0][0] === '❌') return;         // If we didn't like the monkey we delete the message
    if(output[0][1] - 1 == 0) return;

    log(msg, `Sending result`)

    const embed = new discord.MessageEmbed()                                  // Creating a new embed
    .setAuthor(randomnoise(), msg.client.user.displayAvatarURL())
    .setColor(colors[output[0][0]][0])
    .setTitle(`${res['title']}`)
    .setURL(res['link'])
    .setImage(res['link'])
    .setFooter(`${msg.author.username}#${msg.author.discriminator}, votes from: ${users}`, `${msg.author.avatarURL()}`)
    .setTimestamp();

    /**
     * Send message to chat and if the vote was ultra rare
     * automatically pin it (set as option later.)
     */
    msg.channel.send(embed).then(message=>{
        const perms = new Perms(msg)
        if(output[0][0] == '🟧' &amp;&amp; perms.del()) {
            message.pin();
        }
    });
}

/**
 * Inappropriately called function. Actually just validates the URL of a list of strings
 * @param {*} msg 
 */
function getmonkey(msg)
{
    try
    {
        const perms = new Perms(msg)
        log(msg, `Checking to see if it's an image`)
        if(perms.del()) msg.delete().catch();
        // If we really messed up badly we try it all over again.
        if(google_results.length == 0) return Math.round(Math.random()) ? monkeygoogle(msg) : monkeyreddit(msg);

        let imglink = google_results[0]['link'];
        let linktest = !/(?:jpg|jpeg|gif|png)$/.test(imglink);
        /**
         * If the URL we are given is invalid loop recursively through this function 
         */
        if( !linktest &amp;&amp; google_results.length > 0 &amp;&amp; google_results[0] == undefined)
        {
            google_results.shift(); // Delete top result
            return getmonkey(msg);  // Loop function
        }
        sendMessage(msg, google_results[0]); // Send result
    }catch(e)
    {
        // fuck it
    }
}

/**
 * @description Grabs a random monkey image from a number of subreddits.
 * @async
 * @param {*} msg Discord Message Manager
 */
async function monkeyreddit(msg)
{
    const subreddits = ['monkeys','ape','MonkeyMemes','monkeypics']                                                             // Subreddits
    const random_sr = subreddits[Math.floor(Math.random() * subreddits.length)]                                                 // Random subreddit from list
    const body = await fetch(`https://www.reddit.com/r/${random_sr}.json?&amp;limit=600`).then(res=>res.json());                    // Request reddit json list
    log(msg, `Fetching from reddit https://www.reddit.com/r/${random_sr}`)

    const valid = body['data']['children'].filter(post=>!post.data.over_18);                                                    // Make sure the post is PG
    const rm = Math.floor(Math.random()*valid.length);
    const rp = valid[rm]['data'];                                                                                               // Grab random POST

    log(msg, `Got post ${rm} out of ${valid.length}`);

    const media =   rp['media'] === null ?  rp['url'] : 
                    (/mp4|gifv/.test(rp['media']['fallback_url']) ? null : 
                    (rp['media']['type'] != undefined ? rp['media']['oembed']['thumbnail_url'] : null));
    const formatted = {'title': rp['title'], 'link': media}                                                            // Reformat into google data
    if(!/(?:jpg|jpeg|gif|png)/.test(media) || /mp4|gifv/.test(media) || !media) return monkeyreddit(msg);
    else sendMessage(msg, formatted);                                                                                    
}

/**
 * @description Grabs a random monkey image off Google Images using Custom Search Json API
 * @async
 * @param {*} msg Discord Message Manager
 */
async function monkeygoogle(msg)
{
    // Huge god damn array
    const monkeytype = [
            '', '', 
            'silly', 
            'stupid', 
            'funny', 
            'laughing', 
            'banana', 
            'hehe haha', 
            'kung fu panda', 
            'youtube', 
            'halo', 
            'minecraft', 
            'epic',
            'tf2',
            'harambe',
            'kong',
            'meme',
            'reddit',
            'cursed'
    ];
    const token = quote_reached ? process.env.SEARCH_KEY_SECOND : process.env.SEARCH_KEY;
    const randomstart = Math.floor(Math.random()*100);              // Random index start 
    let monkeyvers = Math.floor(Math.random()*monkeytype.length);   // Random index out of 10 (Max items is 10)
    const searchengine = process.env.SEARCH_ENGINE;                 // Search engine to use (enable global search in control panel)
    let monkey = `monkey ${monkeytype[monkeyvers]}`;                // Updating search query
    // God damn that's a long url
    const url = `https://www.googleapis.com/customsearch/v1?key=${token}&amp;cx=${searchengine}&amp;q=${monkey}&amp;searchType=image&amp;start=${randomstart}`;

    if(google_results.length > 0) return getmonkey(msg);                        // No results? We recall this function
    log(msg, `Fetching using key: ${quote_reached} and searching ${monkey}`)
    fetch(url)                                                                  // Fetch API
    .then(res=>{return res.json()})
    .then((res)=>
    {
        log(msg, `Got a result from fetch`)
        if(res['error'])
        {
            switch(res['error']['code'])
            {
                case 429:   // Quota exhausted
                    log(msg, `Quota maxed out on key number: ${quote_reached}`)
                    const d = new Date();                                                           // Creating new date to get PT time off of
                    const PT = d.toLocaleTimeString('en-US', { timeZone: 'America/Los_Angeles' });  // Getting PT time (string)
                    let time = PT.split(':');                                                       // Splitting on :
                    let hours = time[2].includes('PM') ? 12 - time[0] : 24 - time[0];               // Since we're on 12 hour time format we check to see if it's PM and - a different value
                    let mins = 60 - time[1];                                                        // Just get the amount of minutes
                    mins == 0 ? '' : hours = hours - 1;
                    quote_reached++;
                    if(quote_reached >= 2) return monkeyreddit(msg);
                    else return this.monkey(msg);
                break;
                default: console.log(res['error']);
            }
        }
        google_results = res['items'];      // Append into memory - yuck
        getmonkey(msg);                     // Test images
    })
    .catch(e=>{
        errh(e, msg);
    });
}


/**
 * Grabs a random image of a monkey off the internet.
 * @param {*} msg 
 */
module.exports.monkey = async (msg) =>
{
    try
    {
        if((msg.channel === undefined || vote[msg.guild.id]) &amp;&amp; msg.member.guild.me.hasPermission(['MANAGE_MESSAGES'])) return msg.delete().catch();
        const random = Math.round(Math.random())
        log(msg, `RNG Google or Reddit: ${random ? 'Google'.bold : 'Reddit'.bold}`)
        random ? monkeygoogle(msg) : monkeyreddit(msg);        
    }catch(e)
    {
        console.log(e);
        errh(e, msg)
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Perms.html">Perms</a></li><li><a href="UserPerms.html">UserPerms</a></li></ul><h3>Global</h3><ul><li><a href="global.html#bcommand">bcommand</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#db_connect">db_connect</a></li><li><a href="global.html#delete">delete</a></li><li><a href="global.html#delreact">delreact</a></li><li><a href="global.html#err">err</a></li><li><a href="global.html#getmonkey">getmonkey</a></li><li><a href="global.html#google_results">google_results</a></li><li><a href="global.html#invite">invite</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#monkey">monkey</a></li><li><a href="global.html#monkeygoogle">monkeygoogle</a></li><li><a href="global.html#monkeyreddit">monkeyreddit</a></li><li><a href="global.html#quote_reached">quote_reached</a></li><li><a href="global.html#randomnoise">randomnoise</a></li><li><a href="global.html#Reaction_Result">Reaction_Result</a></li><li><a href="global.html#reactions">reactions</a></li><li><a href="global.html#sendMessage">sendMessage</a></li><li><a href="global.html#sendmessage">sendmessage</a></li><li><a href="global.html#timestamp">timestamp</a></li><li><a href="global.html#vote">vote</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.5</a> on Wed Aug 26 2020 14:35:31 GMT+1000 (Australian Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
